using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using CSScriptingLangGenerators.Utils;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace CSScriptingLangGenerators.Mixins;

[Generator]
public class MixinsGenerator : IIncrementalGenerator
{
    private const string MixinAttributeName    = "Mixin";
    private const string AddMixinAttributeName = "AddMixin";

    private void GenerateMixinAttributes(IncrementalGeneratorInitializationContext context) {
        var src = $@"// <auto-generated/>
namespace {Constants.MixinsNamespace};

[System.AttributeUsage(System.AttributeTargets.Class)]
public class {AddMixinAttributeName} : System.Attribute
{{
    public Type MixinType {{ get; }}
    public {AddMixinAttributeName}(Type mixinType) => MixinType = mixinType;
}}

[System.AttributeUsage(System.AttributeTargets.Class)]
public class {MixinAttributeName} : System.Attribute
{{
    public string[] Imports {{get;set;}} = Array.Empty<string>();

    public {MixinAttributeName}() {{}}
    public {MixinAttributeName}(params string[] imports) => Imports = imports;
}}
";

        context.RegisterPostInitializationOutput(
            ctx => ctx.AddSource(
                "MixinAttribute.g.cs",
                SourceText.From(src, Encoding.UTF8)
            )
        );

    }

    public class MixinGenClass
    {
        public ClassDeclarationSyntax Declaration { get; set; }
        public INamedTypeSymbol       Symbol      { get; set; }

        public List<AttributeData>   MixinAttributes       { get; set; }
        public List<AttributeSyntax> MixinAttributesSyntax { get; set; }
    }

    public void Initialize(IncrementalGeneratorInitializationContext context) {
        GenerateMixinAttributes(context);

        var classDeclarationsProvider = context.SyntaxProvider
           .CreateSyntaxProvider(
                predicate: (node, _) => {
                    return node is ClassDeclarationSyntax {AttributeLists.Count: > 0};
                },
                transform: (ctx, _) => {
                    var classDeclaration = (ClassDeclarationSyntax) ctx.Node;
                    var classSymbol      = ModelExtensions.GetDeclaredSymbol(ctx.SemanticModel, classDeclaration)!;

                    var attrs      = classSymbol.GetAttributes();
                    var mixinAttrs = attrs.TryGetAttributes(AddMixinAttributeName).ToList();

                    if (mixinAttrs.Count == 0)
                        return null;

                    var mixinAttrsDecls = mixinAttrs.Select(ma => ma.ApplicationSyntaxReference?.GetSyntax() as AttributeSyntax).ToList();

                    return new MixinGenClass() {
                        Declaration           = classDeclaration,
                        Symbol                = classSymbol as INamedTypeSymbol,
                        MixinAttributes       = mixinAttrs,
                        MixinAttributesSyntax = mixinAttrsDecls
                    };
                }
            )
           .Where(static m => m != null);


        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(classDeclarationsProvider.Collect()),
            ((ctx, t) => {
                var compilation = t.Left;
                var classes     = t.Right;

                foreach (var klass in classes) {
                    var source = GenerateMixinCode(ctx, compilation, klass);
                    ctx.AddSource($"{klass.Declaration.Identifier.Text}_Mixin.g.cs", SourceText.From(source, Encoding.UTF8));
                }
            })
        );

    }


    private static string GenerateMixinCode(
        SourceProductionContext context,
        Compilation             compilation,
        MixinGenClass           klass
    ) {
        var declaration = klass.Declaration;
        var symbol      = klass.Symbol;
        var mixinAttrs  = klass.MixinAttributes;

        var semanticModel = compilation.GetSemanticModel(declaration.SyntaxTree);

        var classMembers = SyntaxFactory.List<MemberDeclarationSyntax>();

        var imports = new HashSet<string>();

        foreach (var attribute in klass.MixinAttributesSyntax) {
            var mixinType = GetMixinTypeFromAttribute(attribute, semanticModel);
            if (mixinType == null)
                continue;

            var mixinClassAttribute = mixinType.GetAttribute(MixinAttributeName);

            // Find the array of strings defined on the mixin attribute
            var mixinImports = mixinClassAttribute?.ConstructorArguments
               .SelectMany(a => {
                    if (a.Kind != TypedConstantKind.Array)
                        return null;
                    return a.Values.Select(v => v.Value?.ToString()).ToArray();
                })
               .ToArray() ?? [];

            imports.UnionWith(mixinImports);

            var mixinClassDeclaration = (mixinType.DeclaringSyntaxReferences[0].GetSyntax() as ClassDeclarationSyntax)!;

            var members = mixinType.GetMembers()
               .Where(m => {
                    // if m is a backing field type of a property, skip it
                    if (m is IFieldSymbol {AssociatedSymbol: IPropertySymbol})
                        return false;
                    if (m is IMethodSymbol {MethodKind: MethodKind.PropertyGet or MethodKind.PropertySet or MethodKind.Constructor})
                        return false;

                    return true;
                })
               .ToList();

            // Get fields, properties, and methods from the mixin class
            foreach (var member in members) {
                var syntax = mixinClassDeclaration.Members
                   .FirstOrDefault(m => m.HasName(member.Name));

                if (symbol.IsStatic) {
                    syntax = syntax?.WithModifiers(
                        SyntaxFactory.TokenList(
                            SyntaxFactory.Token(SyntaxKind.PublicKeyword),
                            SyntaxFactory.Token(SyntaxKind.StaticKeyword)
                        )
                    );
                }
                if (syntax != null) {
                    classMembers = classMembers.Add(syntax);
                    continue;
                }

                Console.WriteLine($"Member {member.Name} not found in mixin class {mixinType.Name}");
            }
        }

        // Create the partial class
        var partialClass = SyntaxFactory.ClassDeclaration(symbol.Name)
           .AddModifiers(declaration.Modifiers.ToArray())
           .AddMembers(classMembers.ToArray());
        
        var namespaceDeclaration = SyntaxFactory.NamespaceDeclaration(SyntaxFactory.ParseName(symbol.GetFullNamespace()))
           .AddMembers(partialClass);

        var compilationUnit = SyntaxFactory.CompilationUnit()
           .AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System")))
           .AddUsings(imports.Select(i => SyntaxFactory.UsingDirective(SyntaxFactory.ParseName(i))).ToArray())
           .AddMembers(namespaceDeclaration)
           .NormalizeWhitespace();

        // .WithAdditionalAnnotations(Formatter.Annotation);

        // ImportAdder.AddImportsAsync(

        return compilationUnit.ToFullString();
    }

    private static INamedTypeSymbol GetMixinTypeFromAttribute(AttributeSyntax attribute, SemanticModel semanticModel) {
        var argument = attribute.ArgumentList?.Arguments.FirstOrDefault();
        if (argument?.Expression is TypeOfExpressionSyntax typeOfExpression) {
            return ModelExtensions.GetTypeInfo(semanticModel, typeOfExpression.Type).Type as INamedTypeSymbol;
        }
        return null;
    }


    // Using SyntaxFactory to generate field
    private static FieldDeclarationSyntax GenerateFieldSyntax(IFieldSymbol field) {
        return SyntaxFactory.FieldDeclaration(
                SyntaxFactory.VariableDeclaration(SyntaxFactory.ParseTypeName(field.Type.ToDisplayString()))
                   .AddVariables(SyntaxFactory.VariableDeclarator(field.Name))
            )
           .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword));
    }

    // Using SyntaxFactory to generate property
    private static PropertyDeclarationSyntax GeneratePropertySyntax(IPropertySymbol property) {
        return SyntaxFactory.PropertyDeclaration(
                SyntaxFactory.ParseTypeName(property.Type.ToDisplayString()),
                SyntaxFactory.Identifier(property.Name)
            )
           .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
           .AddAccessorListAccessors(
                SyntaxFactory.AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                   .WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken)),
                SyntaxFactory.AccessorDeclaration(SyntaxKind.SetAccessorDeclaration)
                   .WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken))
            );
    }

    // Using SyntaxFactory to generate method
    private static MethodDeclarationSyntax GenerateMethodSyntax(IMethodSymbol method) {
        var parameters = method.Parameters.Select(
            p => SyntaxFactory.Parameter(SyntaxFactory.Identifier(p.Name))
               .WithType(SyntaxFactory.ParseTypeName(p.Type.ToDisplayString()))
        ).ToArray();

        return SyntaxFactory.MethodDeclaration(
                SyntaxFactory.ParseTypeName(method.ReturnType.ToDisplayString()),
                SyntaxFactory.Identifier(method.Name)
            )
           .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
           .AddParameterListParameters(parameters)
           .WithBody(
                SyntaxFactory.Block(
                    SyntaxFactory.ParseStatement("// Method body goes here; replace with your logic"))
            );
    }
}