using System.Collections.Immutable;
using System.Linq;
using System.Text;
using CSScriptingLangGenerators.Bindings;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;


namespace CSScriptingLangGenerators;

[Generator]
public class InstructionsSourceGenerator : IIncrementalGenerator
{
    private const string Namespace = "Generators";

    private const string InstructionAttributeName = "VMInstructionAttribute<T>";
    private const string OperandAttributeName     = "VMOperandAttribute";

    private const string AttributeSourceCode = $@"// <auto-generated/>
namespace {Namespace}
{{
    [System.AttributeUsage(System.AttributeTargets.Class, Inherited = true, AllowMultiple = true)]
    public class {InstructionAttributeName} : System.Attribute where T : class
    {{
        public Type OperandType => typeof(T);
    }}

    [System.AttributeUsage(System.AttributeTargets.Class, Inherited = true, AllowMultiple = true)]
    public class {OperandAttributeName} : System.Attribute
    {{
    }}
}}
";

    public void Initialize(IncrementalGeneratorInitializationContext context) {
        context.RegisterPostInitializationOutput(
            ctx => ctx.AddSource(
                "VMAttribute.g.cs",
                SourceText.From(AttributeSourceCode, Encoding.UTF8)
            )
        );

        var provider = context.SyntaxProvider
           .CreateSyntaxProvider(
                (s,   _) => s is ClassDeclarationSyntax,
                (ctx, _) => GetClassDeclarationForSourceGen(ctx)
            )
           .Where(t => t.attributeFound)
           .Select((t, _) => t.Item1);

        // Generate the source code.
        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(provider.Collect()),
            ((ctx, t) => GenerateCode(ctx, t.Left, t.Right))
        );
    }

    private static (ClassDeclarationSyntax, bool attributeFound) GetClassDeclarationForSourceGen(
        GeneratorSyntaxContext context
    ) {
        var classDeclarationSyntax = (ClassDeclarationSyntax) context.Node;

        // Go through all attributes of the class.
        foreach (var attributeListSyntax in classDeclarationSyntax.AttributeLists) {
            foreach (var attributeSyntax in attributeListSyntax.Attributes) {
                var attrSymbol = context.SemanticModel.GetSymbolInfo(attributeSyntax);
                if (attrSymbol.CandidateSymbols.Length == 0)
                    continue;
                var symbol = attrSymbol.CandidateSymbols[0];

                var attributeName = symbol.ContainingType.ToDisplayString();

                if (attributeName is $"{Namespace}.{InstructionAttributeName}" or $"{Namespace}.{OperandAttributeName}")
                    return (classDeclarationSyntax, true);
            }
        }

        return (classDeclarationSyntax, false);
    }
    private void GenerateCode(
        SourceProductionContext                context,
        Compilation                            compilation,
        ImmutableArray<ClassDeclarationSyntax> classDeclarations
    ) {

        foreach (var classDeclarationSyntax in classDeclarations) {
            var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);
            if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
                continue;

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
            var className     = classDeclarationSyntax.Identifier.Text;

            // Check if the class has the [VMInstruction] attribute
            var hasInstructionAttribute = classDeclarationSyntax.AttributeLists
               .SelectMany(al => al.Attributes)
               .Any(a => semanticModel.GetSymbolInfo(a).Symbol?.ContainingType.ToDisplayString() == $"{Namespace}.{InstructionAttributeName}");

            var instructionAttribute = classDeclarationSyntax.AttributeLists
               .SelectMany(al => al.Attributes)
               .FirstOrDefault(a =>
                {
                    var symbInfo = semanticModel.GetSymbolInfo(a);
                    if (symbInfo.CandidateSymbols.Length > 0)
                        return symbInfo.CandidateSymbols[0].ContainingType.ToDisplayString() == $"{Namespace}.{InstructionAttributeName}";
                    return false;
                });

            INamedTypeSymbol operandType = null;
            if (instructionAttribute?.Name is GenericNameSyntax genericInstructionName) {
                if (genericInstructionName.TypeArgumentList.Arguments.Count > 0) {
                    var typeArgSyntax = genericInstructionName.TypeArgumentList.Arguments[0];
                    var typeInfo      = semanticModel.GetTypeInfo(typeArgSyntax);
                    operandType = typeInfo.Type as INamedTypeSymbol;
                }
            }

            if (operandType == null) {
                context.ReportDiagnostic(Diagnostic.Create(Diagnostics.MissingOperandType, classDeclarationSyntax.GetLocation()));
                continue;
            }

            // Build up the source code
            var code = $@"// <auto-generated/>

using System;
using System.Collections.Generic;

namespace {namespaceName};

public partial class {className}
{{
    public {operandType.ToDisplayString()} Operand {{
        get => ({operandType.ToDisplayString()}) _operand;
        set => _operand = value;
    }}
}}
";

            // Add the source code to the compilation.
            context.AddSource($"{className}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }
}