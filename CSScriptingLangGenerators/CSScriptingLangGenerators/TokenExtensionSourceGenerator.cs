using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;


namespace CSScriptingLangGenerators;

[Generator]
public class TokenExtensionSourceGenerator : IIncrementalGenerator
{
    private const string Namespace     = "Generators";
    private const string AttributeName = "ReportAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context) {


        // Filter classes annotated with the [Report] attribute. Only filtered Syntax Nodes can trigger code generation.
        var provider = context.SyntaxProvider
               .CreateSyntaxProvider(
                    (s,   _) => s is StructDeclarationSyntax && IsValidTokenStruct(s),
                    (ctx, _) => GetClassDeclarationForSourceGen(ctx)
                )
            ;


        // Generate the source code.
        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(provider.Collect()),
            ((ctx, t) => GenerateCode(ctx, t.Left, t.Right!))
        );
    }

    private static bool IsValidTokenStruct(SyntaxNode node) {
        if (node is not StructDeclarationSyntax structDeclarationSyntax)
            return false;

        if (structDeclarationSyntax.Identifier.Text != "Token")
            return false;

        return true;
    }

    private static StructDeclarationSyntax GetClassDeclarationForSourceGen(
        GeneratorSyntaxContext context
    ) {
        var structDeclarationSyntax = (StructDeclarationSyntax) context.Node;
        if (context.SemanticModel.GetDeclaredSymbol(structDeclarationSyntax) is not INamedTypeSymbol structSymbol)
            return null;

        // Only allow the struct `CSScriptingLang.Lexing.Token`
        if (structSymbol.ContainingNamespace.ToDisplayString() != "CSScriptingLang.Lexing")
            return null;
        if (structSymbol.Name != "Token")
            return null;

        return structDeclarationSyntax;
    }

    private void GenerateCode(
        SourceProductionContext                 context,
        Compilation                             compilation,
        ImmutableArray<StructDeclarationSyntax> declarations
    ) {
        var tokenTypeEnumSymbol = compilation.GetTypeByMetadataName("CSScriptingLang.Lexing.TokenType");
        if (tokenTypeEnumSymbol == null)
            return;


        foreach (var structDeclarationSyntax in declarations) {
            var semanticModel = compilation.GetSemanticModel(structDeclarationSyntax.SyntaxTree);

            // Symbols allow us to get the compile-time information.
            if (semanticModel.GetDeclaredSymbol(structDeclarationSyntax) is not INamedTypeSymbol structSymbol)
                continue;

            var tokenTypeMethods = tokenTypeEnumSymbol.GetMembers()
               .OfType<IFieldSymbol>()
                // Skip fields which have the `KeywordAttribute` attribute.
               .Where(m => m.GetAttributes().All(a => a.AttributeClass?.Name != "KeywordAttribute"))
               .Select(m => $@"    public bool Is{m.Name} => Type.HasAny(TokenType.{m.Name});");

            var hasKeywordMethods = tokenTypeEnumSymbol.GetMembers()
               .OfType<IFieldSymbol>()
                // Only include fields which have the `KeywordAttribute` attribute.
               .Where(m => m.GetAttributes().Any(a => a.AttributeClass?.Name == "KeywordAttribute"))
               .Select(m => $@"    public bool Is{m.Name}Keyword => Type.HasAny(TokenType.{m.Name});");

            // Build up the source code
            var code = $@"// <auto-generated/>

using System;
using System.Collections.Generic;
using CSScriptingLang.Utils;

namespace {structSymbol.ContainingNamespace.ToDisplayString()};

public partial struct {structDeclarationSyntax.Identifier.Text}
{{

{string.Join("\n", tokenTypeMethods)}

{string.Join("\n", hasKeywordMethods)}

    public bool Is(TokenType type, bool exact = false) => exact ? Type.HasAll(type) : Type.HasAny(type);
    

}}
";

            // Add the source code to the compilation.
            context.AddSource($"{structDeclarationSyntax.Identifier.Text}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }
}